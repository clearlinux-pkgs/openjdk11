
# HG changeset patch
# User igerasim
# Date 1554253997 -3600
# Node ID 1084d119236b64d47042faecb84775f82371d800
# Parent  c61b8801f0e4bdd3f9d39483417fa0cf5340cf9a
8218453: More dynamic RMI interactions
Reviewed-by: aph

diff -r c61b8801f0e4 -r 1084d119236b src/java.rmi/share/classes/sun/rmi/registry/RegistryImpl_Skel.java
--- a/src/java.rmi/share/classes/sun/rmi/registry/RegistryImpl_Skel.java	Wed Apr 03 02:10:23 2019 +0100
+++ b/src/java.rmi/share/classes/sun/rmi/registry/RegistryImpl_Skel.java	Wed Apr 03 02:13:17 2019 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -58,8 +58,24 @@
 
     public void dispatch(java.rmi.Remote obj, java.rmi.server.RemoteCall call, int opnum, long hash)
             throws java.lang.Exception {
-        if (hash != interfaceHash)
-            throw new java.rmi.server.SkeletonMismatchException("interface hash mismatch");
+        if (opnum < 0) {
+            if (hash == 7583982177005850366L) {
+                opnum = 0;
+            } else if (hash == 2571371476350237748L) {
+                opnum = 1;
+            } else if (hash == -7538657168040752697L) {
+                opnum = 2;
+            } else if (hash == -8381844669958460146L) {
+                opnum = 3;
+            } else if (hash == 7305022919901907578L) {
+                opnum = 4;
+            } else {
+                throw new java.rmi.UnmarshalException("invalid method hash");
+            }
+        } else {
+            if (hash != interfaceHash)
+                throw new java.rmi.server.SkeletonMismatchException("interface hash mismatch");
+        }
 
         sun.rmi.registry.RegistryImpl server = (sun.rmi.registry.RegistryImpl) obj;
         switch (opnum) {
diff -r c61b8801f0e4 -r 1084d119236b src/java.rmi/share/classes/sun/rmi/server/UnicastServerRef.java
--- a/src/java.rmi/share/classes/sun/rmi/server/UnicastServerRef.java	Wed Apr 03 02:10:23 2019 +0100
+++ b/src/java.rmi/share/classes/sun/rmi/server/UnicastServerRef.java	Wed Apr 03 02:13:17 2019 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -40,6 +40,7 @@
 import java.rmi.ServerException;
 import java.rmi.UnmarshalException;
 import java.rmi.server.ExportException;
+import java.rmi.server.Operation;
 import java.rmi.server.RemoteCall;
 import java.rmi.server.RemoteRef;
 import java.rmi.server.RemoteStub;
@@ -292,15 +293,14 @@
                 throw new UnmarshalException("error unmarshalling call header",
                                              readEx);
             }
-            if (num >= 0) {
-                if (skel != null) {
+            if (skel != null) {
+                // If there is a skeleton, use it
                     oldDispatch(obj, call, num);
                     return;
-                } else {
-                    throw new UnmarshalException(
-                        "skeleton class not found but required " +
-                        "for client version");
-                }
+
+            } else if (num >= 0){
+                throw new UnmarshalException(
+                        "skeleton class not found but required for client version");
             }
             try {
                 op = in.readLong();
@@ -428,8 +428,8 @@
 
     /**
      * Handle server-side dispatch using the RMI 1.1 stub/skeleton
-     * protocol, given a non-negative operation number that has
-     * already been read from the call stream.
+     * protocol, given a non-negative operation number or negative method hash
+     * that has already been read from the call stream.
      * Exceptions are handled by the caller to be sent to the remote client.
      *
      * @param obj the target remote object for the call
@@ -461,7 +461,8 @@
         }
 
         // if calls are being logged, write out object id and operation
-        logCall(obj, skel.getOperations()[op]);
+        Operation[] operations = skel.getOperations();
+        logCall(obj, op >= 0 && op < operations.length ?  operations[op] : "op: " + op);
         unmarshalCustomCallData(in);
         // dispatch to skeleton for remote object
         skel.dispatch(obj, call, op, hash);

